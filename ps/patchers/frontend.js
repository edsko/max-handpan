/**
 * Functions that max expects to be present when the file is loaded
 */

/**
 * Registered message handlers
 *
 * @see anything
 */
var messageHandlers = {};

/**
 * Respond to messages
 *
 * Max expects <code>anything</code> to be present when the JavaScript is
 * loaded. We <i>can</i> override it later, but since it must be present, we
 * might as well make use of it. On the PureScript side, we will update
 * <code>messageHandlers</code>, and we will read it here.
 */
function anything() {
  if(typeof(messageHandlers[inlet][messagename]) === 'function') {
    messageHandlers[inlet][messagename](arguments);
  } else {
    throw ("anything: Unexpected message " + messagename + "\n");
  }
}
// Generated by purs bundle 0.13.8
var PS = {};
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Apply"] = $PS["Control.Apply"] || {};
  var exports = $PS["Control.Apply"];                    
  var Apply = function (Functor0, apply) {
      this.Functor0 = Functor0;
      this.apply = apply;
  };                      
  var apply = function (dict) {
      return dict.apply;
  };
  exports["Apply"] = Apply;
  exports["apply"] = apply;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Applicative"] = $PS["Control.Applicative"] || {};
  var exports = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];        
  var Applicative = function (Apply0, pure) {
      this.Apply0 = Apply0;
      this.pure = pure;
  };
  var pure = function (dict) {
      return dict.pure;
  };
  var liftA1 = function (dictApplicative) {
      return function (f) {
          return function (a) {
              return Control_Apply.apply(dictApplicative.Apply0())(pure(dictApplicative)(f))(a);
          };
      };
  };
  exports["Applicative"] = Applicative;
  exports["pure"] = pure;
  exports["liftA1"] = liftA1;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Bind"] = $PS["Control.Bind"] || {};
  var exports = $PS["Control.Bind"];
  var Bind = function (Apply0, bind) {
      this.Apply0 = Apply0;
      this.bind = bind;
  };                     
  var bind = function (dict) {
      return dict.bind;
  };
  exports["Bind"] = Bind;
  exports["bind"] = bind;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Monad"] = $PS["Control.Monad"] || {};
  var exports = $PS["Control.Monad"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];                
  var Monad = function (Applicative0, Bind1) {
      this.Applicative0 = Applicative0;
      this.Bind1 = Bind1;
  };
  var ap = function (dictMonad) {
      return function (f) {
          return function (a) {
              return Control_Bind.bind(dictMonad.Bind1())(f)(function (f$prime) {
                  return Control_Bind.bind(dictMonad.Bind1())(a)(function (a$prime) {
                      return Control_Applicative.pure(dictMonad.Applicative0())(f$prime(a$prime));
                  });
              });
          };
      };
  };
  exports["Monad"] = Monad;
  exports["ap"] = ap;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Boolean"] = $PS["Data.Boolean"] || {};
  var exports = $PS["Data.Boolean"];
  var otherwise = true;
  exports["otherwise"] = otherwise;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Function"] = $PS["Data.Function"] || {};
  var exports = $PS["Data.Function"];
  var $$const = function (a) {
      return function (v) {
          return a;
      };
  };
  exports["const"] = $$const;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Functor"] = $PS["Data.Functor"] || {};
  var exports = $PS["Data.Functor"];               
  var Functor = function (map) {
      this.map = map;
  };
  var map = function (dict) {
      return dict.map;
  };
  exports["Functor"] = Functor;
  exports["map"] = map;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.List.Types"] = $PS["Data.List.Types"] || {};
  var exports = $PS["Data.List.Types"];                          
  var Nil = (function () {
      function Nil() {

      };
      Nil.value = new Nil();
      return Nil;
  })();
  var Cons = (function () {
      function Cons(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Cons.create = function (value0) {
          return function (value1) {
              return new Cons(value0, value1);
          };
      };
      return Cons;
  })();
  exports["Nil"] = Nil;
  exports["Cons"] = Cons;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.List"] = $PS["Data.List"] || {};
  var exports = $PS["Data.List"];
  var Data_Boolean = $PS["Data.Boolean"];
  var Data_List_Types = $PS["Data.List.Types"];
  var singleton = function (a) {
      return new Data_List_Types.Cons(a, Data_List_Types.Nil.value);
  };
  var range = function (start) {
      return function (end) {
          if (start === end) {
              return singleton(start);
          };
          if (Data_Boolean.otherwise) {
              var go = function ($copy_s) {
                  return function ($copy_e) {
                      return function ($copy_step) {
                          return function ($copy_rest) {
                              var $tco_var_s = $copy_s;
                              var $tco_var_e = $copy_e;
                              var $tco_var_step = $copy_step;
                              var $tco_done = false;
                              var $tco_result;
                              function $tco_loop(s, e, step, rest) {
                                  if (s === e) {
                                      $tco_done = true;
                                      return new Data_List_Types.Cons(s, rest);
                                  };
                                  if (Data_Boolean.otherwise) {
                                      $tco_var_s = s + step | 0;
                                      $tco_var_e = e;
                                      $tco_var_step = step;
                                      $copy_rest = new Data_List_Types.Cons(s, rest);
                                      return;
                                  };
                                  throw new Error("Failed pattern match at Data.List (line 148, column 3 - line 149, column 65): " + [ s.constructor.name, e.constructor.name, step.constructor.name, rest.constructor.name ]);
                              };
                              while (!$tco_done) {
                                  $tco_result = $tco_loop($tco_var_s, $tco_var_e, $tco_var_step, $copy_rest);
                              };
                              return $tco_result;
                          };
                      };
                  };
              };
              return go(end)(start)((function () {
                  var $220 = start > end;
                  if ($220) {
                      return 1;
                  };
                  return -1 | 0;
              })())(Data_List_Types.Nil.value);
          };
          throw new Error("Failed pattern match at Data.List (line 144, column 1 - line 144, column 32): " + [ start.constructor.name, end.constructor.name ]);
      };
  };
  exports["range"] = range;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Maybe"] = $PS["Data.Maybe"] || {};
  var exports = $PS["Data.Maybe"];
  var Data_Functor = $PS["Data.Functor"];          
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();                                                   
  var functorMaybe = new Data_Functor.Functor(function (v) {
      return function (v1) {
          if (v1 instanceof Just) {
              return new Just(v(v1.value0));
          };
          return Nothing.value;
      };
  });
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["functorMaybe"] = functorMaybe;
})(PS);
(function(exports) {
  "use strict";

  exports.showIntImpl = function (n) {
    return n.toString();
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Show"] = $PS["Data.Show"] || {};
  var exports = $PS["Data.Show"];
  var $foreign = $PS["Data.Show"];
  var Show = function (show) {
      this.show = show;
  };                                                 
  var showInt = new Show($foreign.showIntImpl);
  var show = function (dict) {
      return dict.show;
  };
  exports["show"] = show;
  exports["showInt"] = showInt;
})(PS);
(function(exports) {
  "use strict";

  exports.pureE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };
})(PS["Effect"] = PS["Effect"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Effect"] = $PS["Effect"] || {};
  var exports = $PS["Effect"];
  var $foreign = $PS["Effect"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad = $PS["Control.Monad"];
  var Data_Functor = $PS["Data.Functor"];                    
  var monadEffect = new Control_Monad.Monad(function () {
      return applicativeEffect;
  }, function () {
      return bindEffect;
  });
  var bindEffect = new Control_Bind.Bind(function () {
      return applyEffect;
  }, $foreign.bindE);
  var applyEffect = new Control_Apply.Apply(function () {
      return functorEffect;
  }, Control_Monad.ap(monadEffect));
  var applicativeEffect = new Control_Applicative.Applicative(function () {
      return applyEffect;
  }, $foreign.pureE);
  var functorEffect = new Data_Functor.Functor(Control_Applicative.liftA1(applicativeEffect));
  exports["functorEffect"] = functorEffect;
  exports["monadEffect"] = monadEffect;
})(PS);
(function(exports) {
  "use strict";

  exports.mkEffectFn1 = function mkEffectFn1(fn) {
    return function(x) {
      return fn(x)();
    };
  };

  exports.runEffectFn2 = function runEffectFn2(fn) {
    return function(a) {
      return function(b) {
        return function() {
          return fn(a, b);
        };
      };
    };
  };
})(PS["Effect.Uncurried"] = PS["Effect.Uncurried"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Effect.Uncurried"] = $PS["Effect.Uncurried"] || {};
  var exports = $PS["Effect.Uncurried"];
  var $foreign = $PS["Effect.Uncurried"];
  exports["mkEffectFn1"] = $foreign.mkEffectFn1;
  exports["runEffectFn2"] = $foreign.runEffectFn2;
})(PS);
(function(exports) {
  /**
 * Instead of using <code>EffectFn</code>, we do the wrapping manually.
 * The reason is that Max's JavaScript environment is a little weird, and it
 * it treats <code>post</code> special; this works just fine:
 *
 * <code>
 * var fn = function(x) {
 *   post("This is some other function", x, "\n");
 * }
 *
 * var fnRenamed = fn;
 * fnRenamed(2);
 * </code>
 *
 * but this does not:
 *
 * <code>
 * var postRenamed = post;
 * postRenamed("bye\n");
 * </code>
 */  
  exports.post = function(msg) {
    return function() {
      if(typeof post === 'function')
        post(msg);
      else if(typeof console.log === 'function')
        console.log(msg);
    }
  }

  exports.setInlets = function(numInlets) {
    return function() {
      inlets = numInlets;
    }
  }

  exports.setOutlets = function(numOutlets) {
    return function() {
      outlets = numOutlets;
    }
  }
})(PS["MaxForLive.Global"] = PS["MaxForLive.Global"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["MaxForLive.Global"] = $PS["MaxForLive.Global"] || {};
  var exports = $PS["MaxForLive.Global"];
  var $foreign = $PS["MaxForLive.Global"];                                   
  var postLn = function (str) {
      return $foreign.post(str + "\x0a");
  };
  exports["postLn"] = postLn;
  exports["setInlets"] = $foreign.setInlets;
  exports["setOutlets"] = $foreign.setOutlets;
})(PS);
(function(exports) {
  exports.setHandlerImpl = function(inlet, message, handler) {
    if(messageHandlers[inlet] === undefined) {
      messageHandlers[inlet] = {};
    }

    messageHandlers[inlet][message] = handler;
  }
})(PS["MaxForLive.Handlers"] = PS["MaxForLive.Handlers"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["MaxForLive.Handlers"] = $PS["MaxForLive.Handlers"] || {};
  var exports = $PS["MaxForLive.Handlers"];
  var $foreign = $PS["MaxForLive.Handlers"];
  var Data_Function = $PS["Data.Function"];
  var Effect_Uncurried = $PS["Effect.Uncurried"];                        
  var InvokeHandler = function (invokeHandler) {
      this.invokeHandler = invokeHandler;
  };
  var invokeNoArgs = new InvokeHandler(function (_i) {
      return Data_Function["const"];
  });
  var invokeHandler = function (dict) {
      return dict.invokeHandler;
  };
  var setHandler = function (dictInvokeHandler) {
      return function (v) {
          return function () {
              return $foreign.setHandlerImpl(v.inlet, v.msg, Effect_Uncurried.mkEffectFn1(invokeHandler(dictInvokeHandler)(0)(v.handler)));
          };
      };
  };
  exports["setHandler"] = setHandler;
  exports["invokeNoArgs"] = invokeNoArgs;
})(PS);
(function(exports) {
  exports.new = function(path) {
    return function() {
      return new LiveAPI(null, path);
    }
  }

  exports.objectType = function(obj) {
    return obj.type;
  }

  exports.getCount = function(path, liveAPI) {
    return liveAPI.getcount(path);
  }

  exports.grabControl = function(liveAPI) {
    return function(control) {
      return function() {
        liveAPI.call("grab_control", control);
      }
    }
  }

  exports.releaseControl = function(liveAPI) {
    return function(control) {
      return function() {
        liveAPI.call("release_control", control);
      }
    }
  }
})(PS["MaxForLive.LiveAPI"] = PS["MaxForLive.LiveAPI"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["MaxForLive.LiveAPI"] = $PS["MaxForLive.LiveAPI"] || {};
  var exports = $PS["MaxForLive.LiveAPI"];
  var $foreign = $PS["MaxForLive.LiveAPI"];
  var Data_Show = $PS["Data.Show"];
  var Effect_Uncurried = $PS["Effect.Uncurried"];
  var liveApp = "live_app";       
  var countControlSurfaces = Effect_Uncurried.runEffectFn2($foreign.getCount)("control_surfaces");
  var controlSurface = function (n) {
      return "control_surfaces " + Data_Show.show(Data_Show.showInt)(n);
  };
  exports["liveApp"] = liveApp;
  exports["controlSurface"] = controlSurface;
  exports["countControlSurfaces"] = countControlSurfaces;
  exports["new"] = $foreign["new"];
  exports["objectType"] = $foreign.objectType;
  exports["grabControl"] = $foreign.grabControl;
  exports["releaseControl"] = $foreign.releaseControl;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["MaxForLive.Util"] = $PS["MaxForLive.Util"] || {};
  var exports = $PS["MaxForLive.Util"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Maybe = $PS["Data.Maybe"];                
  var firstJustM = function (dictMonad) {
      return function (as) {
          return function (f) {
              var go = function (v) {
                  if (v instanceof Data_List_Types.Nil) {
                      return Control_Applicative.pure(dictMonad.Applicative0())(Data_Maybe.Nothing.value);
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      return Control_Bind.bind(dictMonad.Bind1())(f(v.value0))(function (mb) {
                          if (mb instanceof Data_Maybe.Nothing) {
                              return go(v.value1);
                          };
                          if (mb instanceof Data_Maybe.Just) {
                              return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Maybe.Just(mb.value0));
                          };
                          throw new Error("Failed pattern match at MaxForLive.Util (line 21, column 8 - line 23, column 34): " + [ mb.constructor.name ]);
                      });
                  };
                  throw new Error("Failed pattern match at MaxForLive.Util (line 17, column 5 - line 17, column 32): " + [ v.constructor.name ]);
              };
              return go(as);
          };
      };
  };
  exports["firstJustM"] = firstJustM;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["MaxForLive.Push"] = $PS["MaxForLive.Push"] || {};
  var exports = $PS["MaxForLive.Push"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_List = $PS["Data.List"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Effect = $PS["Effect"];
  var MaxForLive_LiveAPI = $PS["MaxForLive.LiveAPI"];
  var MaxForLive_Util = $PS["MaxForLive.Util"];                
  var Push = (function () {
      function Push(value0) {
          this.value0 = value0;
      };
      Push.create = function (value0) {
          return new Push(value0);
      };
      return Push;
  })();
  var mkPush = function (push) {
      return new Push({
          grabButtonMatrix: MaxForLive_LiveAPI.grabControl(push)("Button_Matrix"),
          releaseButtonMatrix: MaxForLive_LiveAPI.releaseControl(push)("Button_Matrix")
      });
  };
  var findPush = function __do() {
      var liveApp = MaxForLive_LiveAPI["new"](MaxForLive_LiveAPI.liveApp)();
      var numCS = MaxForLive_LiveAPI.countControlSurfaces(liveApp)();
      return MaxForLive_Util.firstJustM(Effect.monadEffect)(Data_List.range(0)(numCS - 1 | 0))(function (i) {
          return function __do() {
              var controlSurface = MaxForLive_LiveAPI["new"](MaxForLive_LiveAPI.controlSurface(i))();
              var $0 = MaxForLive_LiveAPI.objectType(controlSurface) === "Push2";
              if ($0) {
                  return new Data_Maybe.Just(controlSurface);
              };
              return Data_Maybe.Nothing.value;
          };
      })();
  };
  var $$new = Data_Functor.map(Effect.functorEffect)(Data_Functor.map(Data_Maybe.functorMaybe)(mkPush))(findPush);
  exports["new"] = $$new;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Frontend"] = $PS["Frontend"] || {};
  var exports = $PS["Frontend"];
  var Data_Maybe = $PS["Data.Maybe"];
  var MaxForLive_Global = $PS["MaxForLive.Global"];
  var MaxForLive_Handlers = $PS["MaxForLive.Handlers"];
  var MaxForLive_Push = $PS["MaxForLive.Push"];                
  var registerHandlers = function (v) {
      return function __do() {
          MaxForLive_Handlers.setHandler(MaxForLive_Handlers.invokeNoArgs)({
              inlet: 0,
              msg: "grab",
              handler: v.value0.grabButtonMatrix
          })();
          return MaxForLive_Handlers.setHandler(MaxForLive_Handlers.invokeNoArgs)({
              inlet: 0,
              msg: "release",
              handler: v.value0.releaseButtonMatrix
          })();
      };
  };
  var main = function __do() {
      MaxForLive_Global.setInlets(1)();
      MaxForLive_Global.setOutlets(1)();
      var mPush = MaxForLive_Push["new"]();
      if (mPush instanceof Data_Maybe.Nothing) {
          return MaxForLive_Global.postLn("No push found")();
      };
      if (mPush instanceof Data_Maybe.Just) {
          MaxForLive_Global.postLn("Found the Push. Setting up handlers")();
          return registerHandlers(mPush.value0)();
      };
      throw new Error("Failed pattern match at Frontend (line 24, column 5 - line 29, column 30): " + [ mPush.constructor.name ]);
  };
  exports["main"] = main;
})(PS);
PS["Frontend"].main();
/* END */
